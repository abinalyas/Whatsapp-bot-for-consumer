import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
// import businessConfigRoutes from "./routes/business-config.routes"; // Temporarily disabled

// WhatsApp webhook verification schema
const webhookVerificationSchema = z.object({
  "hub.mode": z.string(),
  "hub.challenge": z.string(),
  "hub.verify_token": z.string(),
});

// WhatsApp incoming message schema
const whatsAppMessageSchema = z.object({
  object: z.string(),
  entry: z.array(z.object({
    id: z.string(),
    changes: z.array(z.object({
      value: z.object({
        messaging_product: z.string(),
        metadata: z.object({
          display_phone_number: z.string(),
          phone_number_id: z.string(),
        }),
        messages: z.array(z.object({
          from: z.string(),
          id: z.string(),
          timestamp: z.string(),
          text: z.object({
            body: z.string(),
          }),
          type: z.string(),
        })).optional(),
      }),
      field: z.string(),
    })),
  })),
});

// Service management schemas
const createServiceSchema = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
  price: z.number().min(0),
  icon: z.string().optional(),
});

// Helper function to send WhatsApp message
async function sendWhatsAppMessage(to: string, message: string): Promise<boolean> {
  try {
    const phoneNumberId = process.env.WHATSAPP_PHONE_ID;
    const accessToken = process.env.WHATSAPP_TOKEN;
    
    if (!phoneNumberId || !accessToken) {
      console.error("WhatsApp credentials not configured");
      return false;
    }

    const url = `https://graph.facebook.com/v17.0/${phoneNumberId}/messages`;
    
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        messaging_product: "whatsapp",
        to: to,
        text: { body: message },
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      console.error("Failed to send WhatsApp message:", error);
      return false;
    }

    return true;
  } catch (error) {
    console.error("Error sending WhatsApp message:", error);
    return false;
  }
}

// Generate UPI payment link (convert USD to INR for payment)
function generateUPILink(amount: number, serviceName: string): string {
  const upiId = process.env.UPI_ID || "sparksalon@upi";
  const inrAmount = Math.round(amount * 83); // Convert USD to INR (approximate rate)
  return `upi://pay?pa=${upiId}&pn=Spark+Salon&am=${inrAmount}&cu=INR&tn=Payment+for+${encodeURIComponent(serviceName)}`;
}

// Process incoming WhatsApp message
async function processWhatsAppMessage(from: string, messageText: string): Promise<void> {
  try {
    console.log("WhatsApp: Processing message from", from, ":", messageText);
    
    // Check if we should use dynamic flow processing
    const shouldUseDynamicFlow = await checkForActiveFlow();
    
    if (shouldUseDynamicFlow) {
      // Use dynamic conversation engine
      await processDynamicWhatsAppMessage(from, messageText);
      return;
    }
    
    // Fall back to static processing
    await processStaticWhatsAppMessage(from, messageText);
  } catch (error) {
    console.error("Error processing WhatsApp message:", error);
    // Send error message to user
    await sendWhatsAppMessage(from, "Sorry, I'm experiencing technical difficulties. Please try again later.");
  }
}

// Check if there's an active flow for dynamic processing
async function checkForActiveFlow(): Promise<boolean> {
  try {
    // In real implementation, this would check database for active flows
    // For now, return false to use static processing
    // TODO: Implement actual flow activation checking
    return false;
  } catch (error) {
    console.error("Error checking for active flow:", error);
    return false;
  }
}

// Dynamic message processing using conversation engine
async function processDynamicWhatsAppMessage(from: string, messageText: string): Promise<void> {
  try {
    console.log("WhatsApp: Using dynamic flow processing for", from);
    
    // This would use the ConversationEngineService
    // For now, send a placeholder response
    await sendWhatsAppMessage(from, "ðŸ¤– Dynamic flow processing is active! This message was generated by your custom bot flow.");
    
    // TODO: Implement actual dynamic processing
    // const dynamicProcessor = new DynamicMessageProcessorService(process.env.DATABASE_URL!);
    // const result = await dynamicProcessor.processMessage(tenantId, conversationId, from, messageText);
    // await sendWhatsAppMessage(from, result.data?.response || "Processing...");
  } catch (error) {
    console.error("Error in dynamic message processing:", error);
    await sendWhatsAppMessage(from, "Sorry, there was an issue with the dynamic flow. Please try again.");
  }
}

// Static message processing (existing logic)
async function processStaticWhatsAppMessage(from: string, messageText: string): Promise<void> {
  try {
    const text = messageText.toLowerCase().trim();
    
    // Get or create conversation
    let conversation = await storage.getConversation(from);
    if (!conversation) {
      conversation = await storage.createConversation({
        phoneNumber: from,
        currentState: "greeting",
      });
    }

    // Store incoming message
    await storage.createMessage({
      conversationId: conversation.id,
      content: messageText,
      isFromBot: false,
    });
    console.log("WhatsApp: Stored user message for conversation", conversation.id);

    let response = "";
    let newState = conversation.currentState;

    // Handle conversation flow
    if (text === "hi" || text === "hello" || conversation.currentState === "greeting") {
      // Send welcome message with services
      const services = await storage.getServices();
      const activeServices = services.filter(s => s.isActive);
      
      response = "ðŸ‘‹ Welcome to Spark Salon!\n\nHere are our services:\n";
      activeServices.forEach(service => {
        const inrPrice = Math.round(service.price * 83); // Convert USD to INR for display
        response += `ðŸ’‡â€â™€ï¸ ${service.name} â€“ â‚¹${inrPrice}\n`;
      });
      response += "\nReply with service name to book.";
      newState = "awaiting_service";
      
    } else if (conversation.currentState === "awaiting_service") {
      // Check if message matches a service
      const services = await storage.getServices();
      const selectedService = services.find(s => 
        s.isActive && s.name.toLowerCase() === text
      );
      
      if (selectedService) {
        // Move to appointment scheduling
        const inrPrice = Math.round(selectedService.price * 83); // Convert USD to INR for display
        response = `Perfect! You've selected ${selectedService.name} (â‚¹${inrPrice}).\n\n`;
        response += "ðŸ“… Now, please select your preferred appointment date.\n\n";
        response += "Available dates:\n";
        
        // Generate next 7 days as options
        const today = new Date();
        for (let i = 1; i <= 7; i++) {
          const futureDate = new Date(today);
          futureDate.setDate(today.getDate() + i);
          const dateStr = futureDate.toLocaleDateString('en-GB', { 
            weekday: 'short', 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
          });
          response += `${i}. ${dateStr}\n`;
        }
        response += "\nReply with the number (1-7) for your preferred date.";
        
        // Update conversation with selected service
        await storage.updateConversation(conversation.id, {
          selectedService: selectedService.id,
          currentState: "awaiting_date",
        });
        
        newState = "awaiting_date";
      } else {
        response = "Sorry, I didn't recognize that service. Please choose from:\n";
        const activeServices = services.filter(s => s.isActive);
        activeServices.forEach(service => {
          response += `â€¢ ${service.name}\n`;
        });
      }
      
    } else if (conversation.currentState === "awaiting_date") {
      // Handle date selection
      const dateChoice = parseInt(text);
      if (dateChoice >= 1 && dateChoice <= 7) {
        const today = new Date();
        const selectedDate = new Date(today);
        selectedDate.setDate(today.getDate() + dateChoice);
        const dateStr = selectedDate.toISOString().split('T')[0]; // YYYY-MM-DD format
        const readableDateStr = selectedDate.toLocaleDateString('en-GB', { 
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        
        response = `Great! You've selected ${readableDateStr}.\n\n`;
        response += "ðŸ• Now, please choose your preferred time slot:\n\n";
        response += "Available times:\n";
        response += "1. 10:00 AM\n";
        response += "2. 11:30 AM\n";
        response += "3. 02:00 PM\n";
        response += "4. 03:30 PM\n";
        response += "5. 05:00 PM\n";
        response += "\nReply with the number (1-5) for your preferred time.";
        
        // Update conversation with selected date
        await storage.updateConversation(conversation.id, {
          selectedDate: dateStr,
          currentState: "awaiting_time",
        });
        
        newState = "awaiting_time";
      } else {
        response = "Please select a valid date option (1-7). Reply with the number for your preferred date.";
      }
      
    } else if (conversation.currentState === "awaiting_time") {
      // Handle time selection
      const timeSlots = ["10:00 AM", "11:30 AM", "02:00 PM", "03:30 PM", "05:00 PM"];
      const timeChoice = parseInt(text);
      
      if (timeChoice >= 1 && timeChoice <= 5) {
        const selectedTime = timeSlots[timeChoice - 1];
        
        // Get service details for payment
        const services = await storage.getServices();
        const selectedService = services.find(s => s.id === conversation.selectedService);
        
        if (selectedService) {
          // Update conversation with selected time first
          const updatedConversation = await storage.updateConversation(conversation.id, {
            selectedTime: selectedTime,
            currentState: "awaiting_payment",
          });
          
          // Get the latest conversation data to ensure we have selectedDate
          const latestConversation = await storage.getConversation(from);
          
          if (latestConversation && latestConversation.selectedDate) {
            // Generate UPI payment link
            const upiLink = generateUPILink(selectedService.price, selectedService.name);
            
            response = `Perfect! Your appointment is scheduled for ${selectedTime}.\n\n`;
            response += `ðŸ“‹ Booking Summary:\n`;
            response += `Service: ${selectedService.name}\n`;
            response += `Date: ${new Date(latestConversation.selectedDate).toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}\n`;
            response += `Time: ${selectedTime}\n`;
            const inrPrice = Math.round(selectedService.price * 83); // Convert USD to INR for display
            response += `Amount: â‚¹${inrPrice}\n\n`;
            response += `ðŸ’³ Please complete your payment:\n${upiLink}\n\n`;
            response += "Complete payment in GPay/PhonePe/Paytm and reply 'paid' to confirm your booking.";
            
            // Create booking record with appointment details
            const appointmentDateTime = new Date(`${latestConversation.selectedDate}T${timeChoice === 1 ? '10:00' : timeChoice === 2 ? '11:30' : timeChoice === 3 ? '14:00' : timeChoice === 4 ? '15:30' : '17:00'}:00`);
            
            await storage.createBooking({
              conversationId: conversation.id,
              serviceId: selectedService.id,
              phoneNumber: from,
              amount: selectedService.price,
              status: "pending",
              appointmentDate: appointmentDateTime,
              appointmentTime: selectedTime,
            });
            
            newState = "awaiting_payment";
          }
        }
      } else {
        response = "Please select a valid time slot (1-5). Reply with the number for your preferred time.";
      }
      
    } else if (conversation.currentState === "awaiting_payment" && text === "paid") {
      // Confirm payment and booking
      const services = await storage.getServices();
      const selectedService = services.find(s => s.id === conversation.selectedService);
      
      response = "âœ… Payment received! Your appointment is confirmed.\n\n";
      response += "ðŸ“‹ Confirmed Booking Details:\n";
      if (selectedService) {
        response += `Service: ${selectedService.name}\n`;
      }
      if (conversation.selectedDate) {
        const appointmentDate = new Date(conversation.selectedDate);
        response += `Date: ${appointmentDate.toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}\n`;
      }
      if (conversation.selectedTime) {
        response += `Time: ${conversation.selectedTime}\n`;
      }
      response += "\nðŸŽ‰ Thank you for choosing Spark Salon! We look forward to serving you.";
      
      // Update booking status
      const bookings = await storage.getBookings();
      const pendingBooking = bookings.find(b => 
        b.conversationId === conversation.id && b.status === "pending"
      );
      
      if (pendingBooking) {
        await storage.updateBooking(pendingBooking.id, {
          status: "confirmed",
          paymentMethod: "UPI",
        });
      }
      
      // Reset conversation state
      newState = "completed";
      
    } else {
      // Default response for unrecognized input
      response = "I'm sorry, I didn't understand that. Type 'hi' to start over or choose a service from our menu.";
    }

    // Update conversation state if needed
    if (newState !== conversation.currentState) {
      await storage.updateConversation(conversation.id, {
        currentState: newState,
      });
    }

    // Send response
    await sendWhatsAppMessage(from, response);
    
    // Store bot response
    await storage.createMessage({
      conversationId: conversation.id,
      content: response,
      isFromBot: true,
    });
    console.log("WhatsApp: Stored bot response for conversation", conversation.id);

  } catch (error) {
    console.error("Error processing WhatsApp message:", error);
    // Send error message to user
    await sendWhatsAppMessage(from, "Sorry, I'm experiencing technical difficulties. Please try again later.");
  }
}

export async function registerRoutes(app: Express): Promise<Server> {
  // WhatsApp webhook verification (GET)
  app.get("/webhook", (req, res) => {
    try {
      console.log("Webhook verification request:", req.query);
      const verification = webhookVerificationSchema.parse(req.query);
      const verifyToken = process.env.WHATSAPP_VERIFY_TOKEN;
      
      console.log("Received verify token:", verification["hub.verify_token"]);
      console.log("Expected verify token:", verifyToken);
      console.log("Mode:", verification["hub.mode"]);
      
      if (verification["hub.mode"] === "subscribe" && 
          verification["hub.verify_token"] === verifyToken) {
        console.log("Verification successful, returning challenge:", verification["hub.challenge"]);
        res.status(200).send(verification["hub.challenge"]);
      } else {
        console.log("Verification failed - mode or token mismatch");
        res.status(403).send("Forbidden");
      }
    } catch (error) {
      console.error("Webhook verification error:", error);
      res.status(400).send("Bad Request");
    }
  });

  // WhatsApp webhook for incoming messages (POST)
  app.post("/webhook", async (req, res) => {
    try {
      const webhookData = whatsAppMessageSchema.parse(req.body);
      
      // Process each message
      for (const entry of webhookData.entry) {
        for (const change of entry.changes) {
          if (change.value.messages) {
            for (const message of change.value.messages) {
              if (message.type === "text") {
                await processWhatsAppMessage(message.from, message.text.body);
              }
            }
          }
        }
      }
      
      res.status(200).send("OK");
    } catch (error) {
      console.error("Webhook processing error:", error);
      res.status(400).send("Bad Request");
    }
  });

  // API routes for dashboard
  app.get("/api/services", async (req, res) => {
    try {
      const services = await storage.getServices();
      console.log("API: Fetching services, found:", services.length);
      res.json(services);
    } catch (error) {
      console.error("Error fetching services:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/services", async (req, res) => {
    try {
      const serviceData = createServiceSchema.parse(req.body);
      const service = await storage.createService(serviceData);
      res.status(201).json(service);
    } catch (error) {
      console.error("Error creating service:", error);
      res.status(400).json({ error: "Invalid service data" });
    }
  });

  app.get("/api/bookings", async (req, res) => {
    try {
      const bookings = await storage.getBookings();
      console.log("API: Fetching bookings, found:", bookings.length);
      res.json(bookings);
    } catch (error) {
      console.error("Error fetching bookings:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.patch("/api/bookings/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;
      
      // Validate status
      if (!status || !['pending', 'confirmed', 'cancelled'].includes(status)) {
        return res.status(400).json({ error: "Invalid status. Must be pending, confirmed, or cancelled" });
      }

      // Get booking details before updating
      const bookings = await storage.getBookings();
      const booking = bookings.find(b => b.id === id);
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }

      // Update booking status
      const updatedBooking = await storage.updateBooking(id, { status });
      if (!updatedBooking) {
        return res.status(404).json({ error: "Booking not found" });
      }

      // Send WhatsApp notification to customer
      if (status === 'confirmed' || status === 'cancelled') {
        try {
          // Get service details for the notification
          const services = await storage.getServices();
          const service = services.find(s => s.id === booking.serviceId);
          const serviceName = service?.name || 'Service';

          let notificationMessage = '';
          
          if (status === 'confirmed') {
            const appointmentDate = booking.appointmentDate 
              ? new Date(booking.appointmentDate).toLocaleDateString('en-GB', { 
                  weekday: 'long', 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric' 
                })
              : 'your selected date';
            
            const appointmentTime = booking.appointmentTime || 'your selected time';

            notificationMessage = `âœ… *Booking Confirmed!*

Your appointment has been confirmed by Spark Salon.

ðŸ“‹ *Booking Details:*
Service: ${serviceName}
Date: ${appointmentDate}
Time: ${appointmentTime}
Amount: â‚¹${booking.amount}

ðŸ“ Please arrive 10 minutes early for your appointment.

Thank you for choosing Spark Salon! ðŸŽ‰`;

          } else if (status === 'cancelled') {
            notificationMessage = `âŒ *Booking Cancelled*

We're sorry to inform you that your booking has been cancelled.

ðŸ“‹ *Cancelled Booking:*
Service: ${serviceName}
Amount: â‚¹${booking.amount}

If you have any questions or would like to reschedule, please contact us or send a new booking request.

We apologize for any inconvenience caused.`;
          }

          // Send WhatsApp notification
          const notificationSent = await sendWhatsAppMessage(booking.phoneNumber, notificationMessage);
          console.log(`WhatsApp notification ${notificationSent ? 'sent' : 'failed'} for booking ${id} status change to ${status}`);
          
        } catch (notificationError) {
          console.error("Error sending WhatsApp notification:", notificationError);
          // Don't fail the booking update if notification fails
        }
      }
      
      res.json(updatedBooking);
    } catch (error) {
      console.error("Error updating booking:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Update service endpoint
  app.patch("/api/services/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      
      const updatedService = await storage.updateService(id, updateData);
      if (!updatedService) {
        return res.status(404).json({ error: "Service not found" });
      }
      
      res.json(updatedService);
    } catch (error) {
      console.error("Error updating service:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Delete service endpoint
  app.delete("/api/services/:id", async (req, res) => {
    try {
      const { id } = req.params;
      
      const success = await storage.deleteService(id);
      if (!success) {
        return res.status(404).json({ error: "Service not found" });
      }
      
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting service:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Settings endpoints for UPI ID
  app.get("/api/settings", async (req, res) => {
    try {
      // For now, return default settings. In a real app, this would be stored in database
      const settings = {
        upiId: "salon@upi",
        businessName: "Spark Salon",
        currency: "INR"
      };
      res.json(settings);
    } catch (error) {
      console.error("Error fetching settings:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.patch("/api/settings", async (req, res) => {
    try {
      const { upiId, businessName } = req.body;
      
      // For now, just return the updated settings
      // In a real app, this would be stored in database
      const settings = {
        upiId: upiId || "salon@upi",
        businessName: businessName || "Spark Salon",
        currency: "INR"
      };
      
      res.json(settings);
    } catch (error) {
      console.error("Error updating settings:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.get("/api/stats", async (req, res) => {
    try {
      const todayBookings = await storage.getTodayBookings();
      const todayRevenue = await storage.getTodayRevenue();
      const allBookings = await storage.getBookings();
      
      // Calculate today's messages (approximate based on bookings)
      const todayMessages = todayBookings.length * 4; // Estimate 4 messages per booking flow
      
      const stats = {
        todayMessages,
        todayBookings: todayBookings.length,
        todayRevenue,
        responseRate: 98, // Static for now
        totalBookings: allBookings.length,
      };
      
      res.json(stats);
    } catch (error) {
      console.error("Error fetching stats:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Test endpoint to simulate WhatsApp message (for development)
  app.post("/api/test-message", async (req, res) => {
    try {
      const { from, message } = req.body;
      await processWhatsAppMessage(from, message);
      res.json({ success: true });
    } catch (error) {
      console.error("Error processing test message:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Business configuration API
  app.get("/api/business-config", (req, res) => {
    try {
      const { getBusinessConfig } = require("./business-config-api");
      const businessType = req.query.type as string;
      const config = getBusinessConfig(businessType);
      res.json({ success: true, data: config });
    } catch (error) {
      console.error("Error fetching business config:", error);
      res.status(500).json({ success: false, error: "Failed to fetch business config" });
    }
  });

  app.get("/api/business-types", (req, res) => {
    try {
      const { getAllBusinessTypes } = require("./business-config-api");
      const types = getAllBusinessTypes();
      res.json({ success: true, data: types });
    } catch (error) {
      console.error("Error fetching business types:", error);
      res.status(500).json({ success: false, error: "Failed to fetch business types" });
    }
  });

  // Bot Flows API endpoints
  app.get("/api/bot-flows", async (req, res) => {
    try {
      // Mock data for now - replace with actual service call
      const mockFlows = [
        {
          id: 'flow_1',
          name: 'Restaurant Booking Flow',
          description: 'Complete flow for restaurant table reservations',
          businessType: 'restaurant',
          isActive: true,
          nodes: [
            { id: '1', type: 'start', name: 'Start', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} },
            { id: '2', type: 'message', name: 'Welcome', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} },
            { id: '3', type: 'question', name: 'Date', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} },
            { id: '4', type: 'end', name: 'End', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} }
          ],
          variables: []
        },
        {
          id: 'flow_2',
          name: 'Customer Support Flow',
          description: 'Handle customer inquiries and support requests',
          businessType: 'restaurant',
          isActive: false,
          nodes: [
            { id: '1', type: 'start', name: 'Start', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} },
            { id: '2', type: 'question', name: 'Issue Type', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} },
            { id: '3', type: 'condition', name: 'Route', position: { x: 0, y: 0 }, configuration: {}, connections: [], metadata: {} }
          ],
          variables: []
        }
      ];

      res.json({
        flows: mockFlows,
        total: mockFlows.length
      });
    } catch (error) {
      console.error("Error fetching bot flows:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.get("/api/bot-flows/:id", async (req, res) => {
    try {
      const { id } = req.params;
      
      // Mock data for now - replace with actual service call
      const mockFlow = {
        id,
        name: 'Sample Restaurant Bot Flow',
        description: 'A sample bot flow for restaurant bookings',
        businessType: 'restaurant',
        isActive: false,
        nodes: [
          {
            id: 'start_1',
            type: 'start',
            name: 'Start',
            position: { x: 100, y: 100 },
            configuration: {},
            connections: [
              {
                id: 'conn_1',
                sourceNodeId: 'start_1',
                targetNodeId: 'message_1',
                label: 'Begin'
              }
            ],
            metadata: {}
          },
          {
            id: 'message_1',
            type: 'message',
            name: 'Welcome Message',
            position: { x: 400, y: 100 },
            configuration: {
              messageText: 'Welcome to our restaurant! I can help you make a reservation.'
            },
            connections: [
              {
                id: 'conn_2',
                sourceNodeId: 'message_1',
                targetNodeId: 'question_1',
                label: 'Next'
              }
            ],
            metadata: {}
          },
          {
            id: 'question_1',
            type: 'question',
            name: 'Ask for Date',
            position: { x: 700, y: 100 },
            configuration: {
              questionText: 'What date would you like to make a reservation for?',
              inputType: 'date',
              variableName: 'reservation_date'
            },
            connections: [],
            metadata: {}
          }
        ],
        variables: [
          {
            name: 'reservation_date',
            type: 'date',
            description: 'The date for the reservation'
          },
          {
            name: 'party_size',
            type: 'number',
            description: 'Number of people'
          }
        ]
      };

      res.json(mockFlow);
    } catch (error) {
      console.error("Error fetching bot flow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/bot-flows", async (req, res) => {
    try {
      const flowData = req.body;
      
      // Mock response for now - replace with actual service call
      const savedFlow = {
        ...flowData,
        id: `flow_${Date.now()}`,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      res.status(201).json(savedFlow);
    } catch (error) {
      console.error("Error creating bot flow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Flow activation endpoints
  app.post("/api/bot-flows/:flowId/activate", async (req, res) => {
    try {
      const { flowId } = req.params;
      
      // In real implementation, this would:
      // 1. Set this flow as active for the tenant
      // 2. Deactivate other flows
      // 3. Update the dynamic message processor
      
      console.log(`Activating flow ${flowId}`);
      
      res.json({ 
        success: true, 
        message: `Flow ${flowId} activated for WhatsApp conversations` 
      });
    } catch (error) {
      console.error("Error activating flow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/bot-flows/:flowId/deactivate", async (req, res) => {
    try {
      const { flowId } = req.params;
      
      // In real implementation, this would:
      // 1. Deactivate this flow
      // 2. Fall back to default/static processing
      
      console.log(`Deactivating flow ${flowId}`);
      
      res.json({ 
        success: true, 
        message: `Flow ${flowId} deactivated, using default responses` 
      });
    } catch (error) {
      console.error("Error deactivating flow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Conversation Engine API endpoints
  app.post("/api/conversations/:conversationId/process", async (req, res) => {
    try {
      const { conversationId } = req.params;
      const { phoneNumber, message } = req.body;

      // Mock response for now - replace with actual conversation engine
      const mockResponse = {
        success: true,
        response: `Processed message "${message}" for conversation ${conversationId}`,
        shouldContinue: true,
      };

      res.json(mockResponse);
    } catch (error) {
      console.error("Error processing conversation message:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.get("/api/conversations/:conversationId/status", async (req, res) => {
    try {
      const { conversationId } = req.params;

      // Mock response for now
      const mockStatus = {
        isActive: true,
        currentNode: 'message-1',
        variables: { userName: 'John' },
        flowId: 'flow-123',
      };

      res.json(mockStatus);
    } catch (error) {
      console.error("Error getting conversation status:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/conversations/test-flow", async (req, res) => {
    try {
      const { flowId, testMessages } = req.body;

      if (!flowId || !testMessages || !Array.isArray(testMessages)) {
        return res.status(400).json({ 
          error: 'flowId and testMessages array are required' 
        });
      }

      // Mock test results
      const results = testMessages.map((message, index) => ({
        input: message,
        success: true,
        response: `Mock response to: ${message}`,
        step: index + 1,
      }));

      res.json({
        success: true,
        testResults: results,
        totalSteps: results.length,
      });
    } catch (error) {
      console.error("Error testing bot flow:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
